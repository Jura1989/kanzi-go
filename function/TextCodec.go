/*
Copyright 2011-2017 Frederic Langlet
Licensed under the Apache License, Version 2.0 (the "License")
you may not use this file except in compliance with the License.
you may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package function

import (
	"errors"
	"fmt"
	kanzi "github.com/flanglet/kanzi"
)

// Simple one-pass text codec. Uses a default (small) static dictionary
// or potentially larger custom one. Generates a dynamic dictionary.
// Encoding: tokenize text into words. If word is in dictionary, emit escape
// and word index (varint encode -> max 2 bytes). Otherwise, emit
// word and add entry in dictionary with word position and length.
// Decoding: If symbol is an escape, read word index (varint decode).
// If current word is not in dictionary, add new entry. Otherwise,
// emit current symbol.

const (
	TC_LOG_THRESHOLD1  = 7
	TC_THRESHOLD1      = 1 << TC_LOG_THRESHOLD1
	TC_THRESHOLD2      = TC_THRESHOLD1 * TC_THRESHOLD1
	TC_MAX_DICT_SIZE   = 1 << 19
	TC_MAX_WORD_LENGTH = 32
	TC_LOG_HASHES_SIZE = 24         // 16 MB
	TC_ESCAPE_TOKEN1   = byte(0x0F) // dictionary word preceded by space symbol
	TC_ESCAPE_TOKEN2   = byte(0x0E) // toggle upper/lower case of first word char
	LF                 = byte(0x0A)
	CR                 = byte(0x0D)
	TC_HASH1           = int32(200002979)
	TC_HASH2           = int32(50004239)
)

type DictEntry struct {
	hash   int32  // full word hash
	pos    int    // position in text
	idx    int32  // index in dictionary
	length int16  // length in text
	buf    []byte // text data
}

type TextCodec struct {
	dictMap        []*DictEntry
	dictList       []DictEntry
	freqs          []int
	staticDictSize int
	dictSize       int
	logHashSize    uint
	hashMask       int32
	isCRLF         bool // EOL = CR+LF ?
}

var (
	TC_STATIC_DICTIONARY = make([]DictEntry, 1024)
	TC_STATIC_DICT_WORDS = createDictionary(unpackDictionary32(TC_DICT_EN_1024), TC_STATIC_DICTIONARY, 1024, 0)
	TC_DELIMITER_CHARS   = initDelimiterChars()
	TC_TEXT_CHARS        = initTextChars()

	// Default dictionary
	// 1024 of the most common English words with at least 2 chars.
	// Each char is 6 bit encoded: 0 to 31. Add 32 to a letter starting a word (MSB).
	// TheBeAndOfInToHaveItThatFor...
	TC_DICT_EN_1024 = []byte{
		byte(0xCC), byte(0x71), byte(0x21), byte(0x12), byte(0x03), byte(0x43), byte(0xB8), byte(0x5A),
		byte(0x0D), byte(0xCC), byte(0xE9), byte(0xC0), byte(0x54), byte(0x4A), byte(0x13), byte(0xCC),
		byte(0x70), byte(0x13), byte(0x94), byte(0xE4), byte(0x78), byte(0x39), byte(0x49), byte(0xC4),
		byte(0xD8), byte(0x84), byte(0xC7), byte(0xB8), byte(0xDC), byte(0x80), byte(0x20), byte(0x3C),
		byte(0x80), byte(0x62), byte(0x04), byte(0xE1), byte(0x51), byte(0x3D), byte(0x84), byte(0x85),
		byte(0x89), byte(0xC0), byte(0x0F), byte(0x31), byte(0xC4), byte(0x62), byte(0x04), byte(0xB6),
		byte(0x39), byte(0x42), byte(0xC3), byte(0xD8), byte(0x73), byte(0xAE), byte(0x46), byte(0x20),
		byte(0x0D), byte(0xB0), byte(0x06), byte(0x23), byte(0x3B), byte(0x31), byte(0xC8), byte(0x4B),
		byte(0x60), byte(0x12), byte(0xA1), byte(0x2B), byte(0x14), byte(0x08), byte(0x78), byte(0x0D),
		byte(0x62), byte(0x54), byte(0x4E), byte(0x32), byte(0xD3), byte(0x93), byte(0xC8), byte(0x71),
		byte(0x36), byte(0x1C), byte(0x04), byte(0xF3), byte(0x1C), byte(0x42), byte(0x11), byte(0xB8),
		byte(0xB0), byte(0xE6), byte(0x11), byte(0x39), byte(0x88), byte(0x54), byte(0x49), byte(0xC0),
		byte(0x4A), byte(0x04), byte(0x44), byte(0x9C), byte(0x83), byte(0x27), byte(0x11), byte(0x18),
		byte(0x8E), byte(0x30), byte(0x4B), byte(0x18), byte(0xB9), byte(0x44), byte(0x76), byte(0x11),
		byte(0x11), byte(0x36), byte(0x20), byte(0xB2), byte(0xF2), byte(0x38), byte(0xC1), byte(0x21),
		byte(0x10), byte(0x20), byte(0x14), byte(0x48), byte(0x4C), byte(0xC7), byte(0x11), byte(0x11),
		byte(0x33), byte(0x1D), byte(0x13), byte(0x94), byte(0x18), byte(0x7C), byte(0xC4), byte(0x2C),
		byte(0xBD), byte(0x87), byte(0x10), byte(0xDD), byte(0x8E), byte(0x44), byte(0xAC), byte(0xC7),
		byte(0x10), byte(0xCE), byte(0x04), byte(0x4F), byte(0x43), byte(0xEE), byte(0x58), byte(0xDB),
		byte(0x94), byte(0x4E), byte(0x83), byte(0x53), byte(0x3A), byte(0x95), byte(0x12), byte(0x4E),
		byte(0x23), byte(0x94), byte(0x2C), byte(0x3B), byte(0x95), byte(0x11), byte(0x1D), byte(0x87),
		byte(0x20), byte(0x21), byte(0xF3), byte(0x1C), byte(0x83), byte(0x4A), byte(0x8C), byte(0x06),
		byte(0x36), byte(0x01), byte(0x8C), byte(0xC7), byte(0x00), byte(0xDA), byte(0xC8), byte(0x28),
		byte(0x4B), byte(0x93), byte(0x1C), byte(0x44), byte(0x67), byte(0x39), byte(0x6C), byte(0xC7),
		byte(0x10), byte(0xDA), byte(0x13), byte(0x4A), byte(0xF1), byte(0x0E), byte(0x3C), byte(0xB1),
		byte(0x33), byte(0x58), byte(0xEB), byte(0x0E), byte(0x44), byte(0x4C), byte(0xC7), byte(0x11),
		byte(0x21), byte(0x21), byte(0x10), byte(0x43), byte(0x6D), byte(0x39), byte(0x6D), byte(0x80),
		byte(0x35), byte(0x39), byte(0x48), byte(0x45), byte(0x24), byte(0xED), byte(0x11), byte(0x6D),
		byte(0x12), byte(0x13), byte(0x21), byte(0x04), byte(0xCC), byte(0x83), byte(0x04), byte(0xB0),
		byte(0x03), byte(0x6C), byte(0x00), byte(0xD6), byte(0x33), byte(0x1C), byte(0x83), byte(0x46),
		byte(0xB0), byte(0x02), byte(0x84), byte(0x9C), byte(0x44), byte(0x44), byte(0xD8), byte(0x42),
		byte(0xCB), byte(0xB8), byte(0xD2), byte(0xD8), byte(0x9C), byte(0x84), byte(0xB5), byte(0x11),
		byte(0x16), byte(0x20), byte(0x15), byte(0x31), byte(0x11), byte(0xD8), byte(0x84), byte(0xC7),
		byte(0x39), byte(0x44), byte(0xE0), byte(0x34), byte(0xE4), byte(0xC7), byte(0x11), byte(0x1B),
		byte(0x4E), byte(0x80), byte(0xB2), byte(0xE1), byte(0x10), byte(0xB2), byte(0x04), byte(0x54),
		byte(0x48), byte(0x44), byte(0x14), byte(0xE4), byte(0x44), byte(0xB8), byte(0x51), byte(0x73),
		byte(0x1C), byte(0xE5), byte(0x06), byte(0x1F), byte(0x23), byte(0xA0), byte(0x18), byte(0x02),
		byte(0x0D), byte(0x49), byte(0x3D), byte(0x87), byte(0x20), byte(0xB1), byte(0x2B), byte(0x01),
		byte(0x24), byte(0xF3), byte(0x38), byte(0xE8), byte(0xCE), byte(0x58), byte(0xDC), byte(0xCE),
		byte(0x0C), byte(0x06), byte(0x32), byte(0x00), byte(0xC1), byte(0x21), byte(0x00), byte(0x22),
		byte(0xB3), byte(0x00), byte(0xA1), byte(0x24), byte(0x00), byte(0x21), byte(0xE3), byte(0x20),
		byte(0x51), byte(0x44), byte(0x44), byte(0x43), byte(0x53), byte(0xD8), byte(0x71), byte(0x11),
		byte(0x12), byte(0x11), byte(0x13), byte(0x58), byte(0x41), byte(0x0D), byte(0xCC), byte(0x73),
		byte(0x92), byte(0x12), byte(0x45), byte(0x44), byte(0x37), byte(0x21), byte(0x04), byte(0x37),
		byte(0x43), byte(0x43), byte(0x11), byte(0x18), byte(0x01), byte(0x39), byte(0x44), byte(0xEE),
		byte(0x34), byte(0x48), byte(0x0B), byte(0x48), byte(0xE9), byte(0x40), byte(0x09), byte(0x3B),
		byte(0x14), byte(0x49), byte(0x38), byte(0x02), byte(0x4D), byte(0x40), byte(0x0B), byte(0x2D),
		byte(0x8B), byte(0xD1), byte(0x11), byte(0x51), byte(0x0D), byte(0x4E), byte(0x45), byte(0xCF),
		byte(0x10), byte(0x24), byte(0xE2), byte(0x38), byte(0xD4), byte(0xC0), byte(0x20), byte(0xD8),
		byte(0x8E), byte(0x34), byte(0x21), byte(0x11), byte(0x36), byte(0xC1), byte(0x32), byte(0x08),
		byte(0x73), byte(0x8E), byte(0x2F), byte(0x81), byte(0x00), byte(0x47), byte(0x32), byte(0x0F),
		byte(0xAC), byte(0x00), byte(0x63), byte(0x50), byte(0x49), byte(0x15), byte(0x11), byte(0x1C),
		byte(0xCE), byte(0x58), byte(0x04), byte(0x43), byte(0x98), byte(0x84), byte(0x4B), byte(0x94),
		byte(0x84), byte(0x4C), byte(0x98), byte(0xB0), byte(0x12), byte(0x4A), byte(0x60), byte(0x12),
		byte(0xA8), byte(0x41), byte(0x0F), byte(0xD8), byte(0xE4), byte(0x4B), byte(0x0F), byte(0x24),
		byte(0xC8), byte(0x2C), byte(0xBD), byte(0x84), byte(0x35), byte(0x3C), byte(0x87), byte(0x39),
		byte(0x42), byte(0xC3), byte(0xC8), byte(0xF1), byte(0x0D), byte(0x0F), byte(0x24), byte(0xC0),
		byte(0x18), byte(0x48), byte(0xCE), byte(0x09), byte(0x33), byte(0x91), byte(0xB0), byte(0x81),
		byte(0x87), byte(0x4E), byte(0x93), byte(0x81), byte(0x98), byte(0xE8), byte(0x8E), byte(0x35),
		byte(0x32), byte(0x0D), byte(0x50), byte(0x49), byte(0x15), byte(0x11), byte(0x16), byte(0x0E),
		byte(0x34), byte(0x4B), byte(0x44), byte(0x54), byte(0x44), byte(0x60), byte(0x35), byte(0x25),
		byte(0x84), byte(0x46), byte(0x51), byte(0x16), byte(0xB0), byte(0x40), byte(0x0D), byte(0x8C),
		byte(0x81), byte(0x45), byte(0x11), byte(0x11), byte(0x0D), byte(0x08), byte(0x4C), byte(0xC4),
		byte(0x34), byte(0x3B), byte(0x44), byte(0x10), byte(0x3A), byte(0xC4), byte(0x01), byte(0x51),
		byte(0x33), byte(0x45), byte(0x8B), byte(0x48), byte(0x08), byte(0x49), byte(0xCE), byte(0x2C),
		byte(0x3C), byte(0x8E), byte(0x30), byte(0x44), byte(0xC7), byte(0x20), byte(0xD1), byte(0xA0),
		byte(0x48), byte(0xAD), byte(0x80), byte(0x44), byte(0xCA), byte(0xC8), byte(0x3E), byte(0x23),
		byte(0x95), byte(0x11), byte(0x1A), byte(0x12), byte(0x49), byte(0x41), byte(0x27), byte(0x00),
		byte(0xF3), byte(0xC4), byte(0x37), byte(0x35), byte(0x11), byte(0x36), byte(0xB3), byte(0x8E),
		byte(0x2B), byte(0x25), byte(0x11), byte(0x12), byte(0x32), byte(0x12), byte(0x08), byte(0xE5),
		byte(0x44), byte(0x46), byte(0x52), byte(0x06), byte(0x1D), byte(0x3B), byte(0x00), byte(0x0E),
		byte(0x32), byte(0x11), byte(0x10), byte(0x24), byte(0xC8), byte(0x38), byte(0xD8), byte(0x06),
		byte(0x44), byte(0x41), byte(0x32), byte(0x38), byte(0xC1), byte(0x0E), byte(0x34), byte(0x49),
		byte(0x40), byte(0x20), byte(0xBC), byte(0x44), byte(0x48), byte(0xF1), byte(0x02), byte(0x4E),
		byte(0xD3), byte(0x93), byte(0x20), byte(0x21), byte(0x22), byte(0x1C), byte(0xE2), byte(0x02),
		byte(0x12), byte(0x11), byte(0x06), byte(0x20), byte(0xDC), byte(0xC7), byte(0x44), byte(0x41),
		byte(0x32), byte(0x61), byte(0x24), byte(0xC4), byte(0x32), byte(0xB1), byte(0x15), byte(0x10),
		byte(0xB9), byte(0x44), byte(0x10), byte(0xBB), byte(0x04), byte(0x11), byte(0x38), byte(0x8E),
		byte(0x30), byte(0xF0), byte(0x0D), byte(0x62), byte(0x13), byte(0x97), byte(0xC8), byte(0x73),
		byte(0x96), byte(0xBC), byte(0xB0), byte(0x18), byte(0xAC), byte(0x85), byte(0x44), byte(0xAC),
		byte(0x44), byte(0xD3), byte(0x11), byte(0x19), byte(0x06), byte(0x1A), byte(0xD5), byte(0x0C),
		byte(0x04), byte(0x44), byte(0x6E), byte(0x3C), byte(0x43), byte(0x6F), byte(0x44), byte(0xE0),
		byte(0x4B), byte(0x10), byte(0xC9), byte(0x40), byte(0x4E), byte(0x70), byte(0x0D), byte(0x0E),
		byte(0xC1), byte(0x00), byte(0x49), byte(0x44), byte(0x44), byte(0xC1), byte(0x41), byte(0x12),
		byte(0x4C), byte(0x83), byte(0x8D), byte(0x88), byte(0x02), byte(0xCB), byte(0xC4), byte(0x43),
		byte(0x04), byte(0x30), byte(0x11), byte(0x11), byte(0x88), byte(0x44), byte(0x53), byte(0x00),
		byte(0x83), byte(0x6F), byte(0x51), byte(0x3B), byte(0x44), byte(0x5D), byte(0x38), byte(0x87),
		byte(0x00), byte(0x84), byte(0x72), byte(0x4C), byte(0x04), byte(0x53), byte(0xC5), byte(0x43),
		byte(0x71), byte(0x00), byte(0x84), byte(0x84), byte(0x98), byte(0xE0), byte(0x0B), byte(0xC4),
		byte(0x40), byte(0x0B), byte(0x2D), byte(0x89), byte(0xCE), byte(0x30), byte(0x4C), byte(0xC4),
		byte(0x02), byte(0x20), byte(0x0D), byte(0x0C), byte(0x80), byte(0xC0), byte(0x4C), byte(0x4B),
		byte(0x0E), byte(0x34), byte(0x46), byte(0x21), byte(0x51), byte(0x22), byte(0x0D), byte(0x11),
		byte(0x24), byte(0xB8), byte(0x39), byte(0x43), byte(0x46), byte(0x98), byte(0xE3), byte(0x83),
		byte(0x88), byte(0xE5), byte(0x11), byte(0x4E), byte(0x52), byte(0x0D), byte(0x0E), byte(0xA3),
		byte(0x4E), byte(0x5A), byte(0xA2), byte(0x0D), byte(0x0E), byte(0x71), byte(0x0B), byte(0x3E),
		byte(0xD2), byte(0x06), byte(0x1D), byte(0x38), byte(0x87), byte(0x20), byte(0xB0), byte(0xEB),
		byte(0x39), byte(0x3E), byte(0x0E), byte(0x51), byte(0x1D), byte(0x12), byte(0x91), byte(0x81),
		byte(0x38), byte(0x11), byte(0x2D), byte(0x8E), byte(0x44), byte(0x38), byte(0x48), byte(0x4F),
		byte(0x50), byte(0x0D), byte(0xB0), byte(0xE3), byte(0x53), byte(0x1E), byte(0x70), byte(0x0B),
		byte(0x16), byte(0xB3), byte(0x96), byte(0xB0), byte(0x82), byte(0xCB), byte(0x20), byte(0xE3),
		byte(0x67), byte(0x20), byte(0x61), byte(0xEE), byte(0x44), byte(0x60), byte(0x0D), byte(0x21),
		byte(0x90), byte(0x13), byte(0x20), byte(0xE3), byte(0x71), byte(0x10), byte(0x39), byte(0x91),
		byte(0x10), byte(0x43), byte(0x61), byte(0x2D), byte(0x41), byte(0x36), byte(0x1C), byte(0x84),
		byte(0xC4), byte(0x84), byte(0xB0), byte(0x02), byte(0x2B), byte(0x83), byte(0x94), byte(0x45),
		byte(0x21), byte(0x0B), byte(0x16), byte(0x42), byte(0x06), byte(0x1D), byte(0x38), byte(0x4E),
		byte(0x4C), byte(0x7A), byte(0xC8), byte(0x4D), byte(0x32), byte(0xC4), byte(0x9C), byte(0xE5),
		byte(0x12), byte(0x12), byte(0xB1), byte(0x13), byte(0x8C), byte(0x44), byte(0x8F), byte(0x21),
		byte(0x31), byte(0x2F), byte(0x44), byte(0xE5), byte(0x48), byte(0x0C), byte(0x4C), byte(0x84),
		byte(0x45), byte(0x52), byte(0x02), byte(0x12), byte(0x72), byte(0x0C), byte(0x48), byte(0x42),
		byte(0xC5), byte(0x95), byte(0x12), byte(0x04), byte(0x34), byte(0x38), byte(0xC4), byte(0x48),
		byte(0x24), byte(0x48), byte(0x04), byte(0x49), byte(0x40), byte(0x4C), byte(0x71), byte(0x11),
		byte(0x8C), byte(0x45), byte(0x44), byte(0x2C), byte(0xE3), byte(0xCC), byte(0x10), byte(0xD4),
		byte(0xE0), byte(0x58), byte(0x06), byte(0x2A), byte(0x20), byte(0xB2), byte(0xF3), byte(0x44),
		byte(0x83), byte(0xE7), byte(0x39), byte(0x44), byte(0x66), byte(0x00), byte(0xC1), byte(0x2E),
		byte(0x15), byte(0x31), byte(0x0D), byte(0xBC), byte(0xB0), byte(0x0D), byte(0x4E), byte(0xF2),
		byte(0xC0), byte(0x08), byte(0x49), byte(0x0D), byte(0x0E), byte(0x03), byte(0x0E), byte(0x34),
		byte(0x6C), byte(0x88), byte(0x34), byte(0x21), byte(0x32), byte(0x4C), byte(0x03), byte(0x43),
		byte(0x8C), byte(0x44), byte(0x88), byte(0x18), byte(0xDB), byte(0xC0), byte(0x45), byte(0x32),
		byte(0x02), byte(0x50), byte(0xB0), byte(0x11), byte(0xC9), byte(0x40), byte(0xC3), byte(0x10),
		byte(0xD2), byte(0xD8), byte(0xB0), byte(0x43), byte(0x01), byte(0x11), byte(0x1B), byte(0xC0),
		byte(0x62), byte(0xB0), byte(0x16), byte(0x84), byte(0xE3), byte(0x8A), byte(0xC8), byte(0x82),
		byte(0xC4), byte(0x34), byte(0x21), byte(0x20), byte(0x2C), byte(0xC3), byte(0x92), byte(0x4E),
		byte(0x83), byte(0x42), byte(0x2D), byte(0x40), byte(0xC4), byte(0x80), byte(0x60), byte(0x08),
		byte(0x36), byte(0x42), byte(0x13), byte(0x1C), byte(0x44), byte(0x73), byte(0x38), byte(0xE2),
		byte(0xE5), byte(0x21), byte(0x51), byte(0x2E), byte(0x34), byte(0x21), byte(0x2B), byte(0x10),
		byte(0x04), byte(0x93), byte(0x91), byte(0x73), byte(0xCB), byte(0x00), byte(0x83), byte(0x68),
		byte(0x0C), byte(0x43), byte(0x53), byte(0x20), byte(0x56), byte(0x34), byte(0x35), byte(0x32),
		byte(0x0B), byte(0xC8), byte(0x84), byte(0xC4), byte(0xB0), byte(0x83), byte(0x54), byte(0x4C),
		byte(0x48), byte(0x8E), byte(0x50), byte(0xF2), byte(0xC4), byte(0xD8), byte(0x41), byte(0x0A),
		byte(0xB0), byte(0x04), byte(0xD3), byte(0x11), byte(0x18), byte(0x51), byte(0x20), byte(0xD1),
		byte(0xA3), byte(0x11), byte(0x30), byte(0x08), byte(0x2E), byte(0x83), byte(0x45), byte(0x39),
		byte(0x13), byte(0x00), byte(0x4C), byte(0x83), byte(0x8D), byte(0xB4), byte(0xE4), byte(0xC7),
		byte(0x20), byte(0xD1), byte(0xA0), byte(0x35), byte(0x84), byte(0xC7), byte(0x20), byte(0xD1),
		byte(0xA4), byte(0x54), byte(0x44), byte(0x58), byte(0x4C), byte(0x72), byte(0x0D), byte(0x1A),
		byte(0x01), byte(0x8E), byte(0xAC), byte(0x40), byte(0x03), byte(0xC8), byte(0xE3), byte(0x04),
		byte(0x4C), byte(0x83), byte(0x04), byte(0x4B), byte(0x43), byte(0x43), byte(0x11), byte(0x14),
		byte(0x93), byte(0x00), byte(0xD0), byte(0xF6), byte(0x1C), byte(0x44), byte(0xC7), byte(0x11),
		byte(0x1B), byte(0x40), byte(0x4D), byte(0x44), byte(0x44), byte(0xCC), byte(0xE1), byte(0x84),
		byte(0x4C), byte(0x71), byte(0x11), byte(0x94), byte(0xE2), byte(0xCB), byte(0x39), byte(0x6B),
		byte(0xC0), byte(0x44), byte(0x43), byte(0x53), byte(0xC9), byte(0x33), byte(0x8F), byte(0xA0),
		byte(0xD0), byte(0xC4), byte(0x10), byte(0x38), byte(0xC8), byte(0x14), byte(0x52), byte(0x02),
		byte(0x50), byte(0xB4), byte(0xEF), byte(0x50), byte(0x12), byte(0xC8), byte(0x0A), byte(0x02),
		byte(0xD1), byte(0x10), byte(0x00), byte(0xD8), byte(0xC8), byte(0xF1), byte(0x00), byte(0x2A),
		byte(0xC0), byte(0x08), byte(0x35), byte(0x30), byte(0x08), byte(0x37), byte(0x11), byte(0x0C),
		byte(0x00), byte(0x83), byte(0x67), byte(0x10), byte(0x04), byte(0x60), byte(0x2C), byte(0xB3),
		byte(0x96), byte(0xB0), byte(0x40), byte(0xC8), byte(0x02), byte(0xE1), byte(0x45), byte(0x20),
		byte(0x21), byte(0x21), byte(0x10), byte(0xD1), byte(0x05), byte(0x21), byte(0x38), byte(0xCE),
		byte(0x39), byte(0x19), byte(0xD4), byte(0x1A), byte(0xF1), byte(0x11), byte(0x48), byte(0xE3),
		byte(0x6B), byte(0x01), byte(0x31), byte(0x11), byte(0x8D), byte(0x44), byte(0x48), byte(0x34),
		byte(0x6D), byte(0x80), byte(0x46), byte(0x72), byte(0x12), byte(0x4C), byte(0xE4), byte(0x58),
		byte(0x81), byte(0x11), byte(0x94), byte(0x13), byte(0x62), byte(0x13), byte(0x1C), byte(0x83),
		byte(0x72), byte(0x11), byte(0x38), byte(0x11), byte(0x4C), byte(0x80), byte(0x8B), byte(0x13),
		byte(0x24), byte(0xC0), byte(0x4C), byte(0x83), byte(0x8D), byte(0xB0), byte(0xE4), byte(0x4D),
		byte(0x20), byte(0xD1), byte(0xB6), byte(0x00), byte(0xB2), byte(0xA4), byte(0x54), byte(0x43),
		byte(0x53), byte(0xD8), byte(0x83), byte(0x62), byte(0x1C), byte(0xE3), byte(0x92), byte(0x12),
		byte(0x11), byte(0x07), byte(0x01), byte(0x52), byte(0x0E), byte(0x47), byte(0x21), byte(0xCE),
		byte(0x39), byte(0x39), byte(0x48), byte(0x44), byte(0x49), byte(0x4E), byte(0x38), byte(0x3C),
		byte(0xC8), byte(0x4C), byte(0xB1), byte(0x20), byte(0x44), byte(0xE5), byte(0x0D), byte(0x0E),
		byte(0x02), byte(0x11), byte(0xCC), byte(0x40), byte(0x02), byte(0x1C), byte(0x44), byte(0x66),
		byte(0x00), byte(0xFC), byte(0x94), byte(0x04), byte(0x91), byte(0x02), byte(0x4E), byte(0x43),
		byte(0x4E), byte(0x50), byte(0x61), byte(0xEF), byte(0x44), byte(0xE5), byte(0x44), byte(0x80),
		byte(0x24), byte(0x4E), byte(0x49), byte(0x28), byte(0x0B), byte(0x4C), byte(0x73), byte(0x94),
		byte(0x18), byte(0x79), byte(0xC4), byte(0x00), byte(0x39), byte(0x4E), byte(0x39), byte(0x3C),
		byte(0x84), byte(0x08), byte(0xE3), byte(0x43), byte(0x84), byte(0xE6), byte(0x2C), byte(0x00),
		byte(0x83), byte(0x6B), byte(0x20), byte(0x48), byte(0x01), byte(0x2C), byte(0x48), byte(0x88),
		byte(0x54), byte(0x82), byte(0xF3), byte(0x00), byte(0x12), byte(0xC4), byte(0xAC), byte(0xE5),
		byte(0x44), byte(0xBD), byte(0x13), byte(0x82), byte(0x11), byte(0x24), byte(0xAE), byte(0x14),
		byte(0x51), byte(0x11), byte(0xC9), byte(0x35), byte(0x03), byte(0x10), byte(0xD4), byte(0xE2),
		byte(0x38), byte(0xD4), byte(0x88), byte(0x0C), byte(0x44), byte(0x60), byte(0x3C), byte(0xF1),
		byte(0x00), byte(0x47), byte(0x24), byte(0xD4), byte(0x0D), byte(0x88), byte(0x54), byte(0x62),
		byte(0xD1), byte(0x00), byte(0x44), byte(0xB6), byte(0x27), byte(0x50), byte(0xC0), byte(0x0D),
		byte(0x91), byte(0x52), byte(0x03), byte(0x10), byte(0xD0), byte(0x84), byte(0xCC), byte(0x45),
		byte(0xD3), byte(0xB0), byte(0x44), byte(0xC7), byte(0x38), byte(0x3A), byte(0x0D), byte(0x08),
		byte(0xB5), byte(0x03), byte(0x20), byte(0xD1), byte(0xB2), byte(0x10), byte(0xD0), byte(0xF1),
		byte(0x10), byte(0x02), byte(0xC8), byte(0x64), byte(0x4C), byte(0x84), byte(0x35), byte(0x21),
		byte(0x21), byte(0x50), byte(0x82), byte(0xC3), byte(0x88), byte(0xE3), byte(0x53), byte(0x44),
		byte(0xE2), byte(0xE0), byte(0x50), byte(0x32), byte(0x04), byte(0x34), byte(0x21), byte(0x32),
		byte(0x11), byte(0x51), byte(0x11), byte(0x00), byte(0xB8), byte(0x94), byte(0x4E), byte(0x23),
		byte(0x8B), byte(0x2C), byte(0x41), byte(0x84), byte(0xA0), byte(0xD4), byte(0xC4), byte(0x44),
		byte(0x44), byte(0x93), byte(0xC9), byte(0x40), byte(0x82), byte(0x11), byte(0x24), byte(0xB2),
		byte(0x3C), byte(0x40), byte(0x88), byte(0x00), byte(0xBC), byte(0x48), byte(0x48), byte(0xA9),
		byte(0x17), byte(0x3C), byte(0x44), byte(0x48), byte(0x10), byte(0xD0), byte(0x84), byte(0x84),
		byte(0x41), byte(0xC8), byte(0x34), byte(0x38), byte(0x44), byte(0x4D), byte(0x31), byte(0x11),
		byte(0xC4), byte(0x44), byte(0x94), byte(0x2D), byte(0x3C), byte(0xD1), byte(0x10), byte(0x04),
		byte(0xF2), byte(0x21), byte(0x7C), byte(0x44), byte(0x2C), byte(0x04), byte(0xC8), byte(0x38),
		byte(0xD4), byte(0x87), byte(0x20), byte(0xF8), byte(0x0D), byte(0x20), byte(0xC0), byte(0x0B),
		byte(0xA0), byte(0xC3), byte(0xD1), byte(0x39), byte(0x51), byte(0x27), byte(0x00), byte(0x84),
		byte(0x72), byte(0x4C), byte(0x06), byte(0x33), byte(0x38), byte(0xFC), byte(0x44), byte(0x0D),
		byte(0x40), byte(0x84), byte(0xBC), byte(0x44), byte(0x47), byte(0x00), byte(0xF4), byte(0xAB),
		byte(0x01), byte(0x31), byte(0x36), byte(0x44), byte(0x84), byte(0xC4), byte(0x46), byte(0xF2),
		byte(0x02), byte(0x2A), byte(0x42), byte(0xD2), byte(0x13), byte(0x22), byte(0x06), byte(0x34),
		byte(0x81), byte(0x48), byte(0x08), byte(0x03), byte(0x53), byte(0x88), byte(0x70), byte(0x0D),
		byte(0x08), byte(0x49), byte(0xCE), byte(0x4C), byte(0x42), byte(0xE6), byte(0x10), byte(0xD1),
		byte(0x11), byte(0x00), byte(0xBC), byte(0x4E), byte(0x08), byte(0xAC), byte(0x44), byte(0x41),
		byte(0x42), byte(0x11), byte(0x12), byte(0x02), byte(0xCE), byte(0x34), byte(0x69), byte(0x48),
		byte(0x4F), byte(0x31), byte(0xC4), byte(0x31), byte(0x21), byte(0x0B), byte(0x54), byte(0x44),
		byte(0xB1), byte(0x10), byte(0xF3), byte(0x91), byte(0x4E), byte(0x23), byte(0x8D), byte(0x0C),
		byte(0x84), byte(0xC8), byte(0x38), byte(0xDC), byte(0x44), byte(0x00), byte(0x21), byte(0xF3),
		byte(0x45), byte(0x44), byte(0xC7), byte(0x90), byte(0x51), byte(0x4E), byte(0x45), byte(0x38),
		byte(0xC4), byte(0x08), byte(0x80), byte(0xC4), byte(0xC4), byte(0x04), byte(0xC4), byte(0x90),
		byte(0x35), byte(0x02), byte(0x01), byte(0x32), byte(0x0E), byte(0x36), byte(0x53), byte(0x91),
		byte(0x08), byte(0x49), byte(0x80), byte(0x44), byte(0x31), byte(0x0D), byte(0x8D), byte(0x15),
		byte(0x06), byte(0xAC), byte(0x40), byte(0x03), byte(0x11), byte(0x1D), byte(0x4E), byte(0x20),
		byte(0x21), byte(0x30), byte(0x50), byte(0x84), byte(0xC4), byte(0xD8), byte(0x73), byte(0x8B),
		byte(0x13), byte(0x21), byte(0x04), byte(0x32), byte(0xC2), byte(0x0D), byte(0x0E), byte(0x52),
		byte(0x0D), byte(0x00), byte(0xB2), byte(0xD8), byte(0xC8), byte(0x84), byte(0x71), byte(0x11),
		byte(0x35), byte(0x11), byte(0x36), byte(0x54), byte(0x44), byte(0x13), byte(0x24), byte(0xCE),
		byte(0x45), byte(0x8C), byte(0x44), byte(0x48), byte(0xF3), byte(0x8D), byte(0x0E), byte(0xF5),
		byte(0x12), byte(0x1E), byte(0x00), byte(0x82), byte(0x39), byte(0x10), byte(0xC8), byte(0x34),
		byte(0x68), byte(0x51), byte(0x39), byte(0x31), byte(0xC4), byte(0x46), byte(0xB1), byte(0x00),
		byte(0x44), byte(0xDC), byte(0x8E), byte(0x36), byte(0x73), byte(0x8F), byte(0x12), byte(0x31),
		byte(0x15), byte(0x10), byte(0xB3), byte(0x8F), byte(0x94), byte(0x41), byte(0x0B), byte(0x20),
		byte(0xD1), byte(0xB1), byte(0x10), byte(0x00), byte(0xE2), byte(0x01), byte(0x14), byte(0x58),
		byte(0x8C), byte(0x84), byte(0x84), byte(0x01), byte(0x21), byte(0x31), byte(0x38), byte(0x00),
		byte(0xF5), byte(0x01), byte(0x12), byte(0x0E), byte(0x51), byte(0x28), byte(0x40), byte(0x2C),
		byte(0xB8), byte(0x80), byte(0x48), byte(0x4B), byte(0x8F), byte(0x11), byte(0x10), byte(0x13),
		byte(0x20), byte(0xE3), byte(0x62), byte(0x2C), byte(0xE4), byte(0x84), byte(0xD4), byte(0x84),
		byte(0x88), byte(0x4F), byte(0x11), byte(0x02), byte(0x10), byte(0x85), byte(0x44), byte(0x85),
		byte(0x42), byte(0x0B), byte(0x0C), byte(0x83), byte(0x46), byte(0xD4), byte(0x02), byte(0xD4),
		byte(0x13), byte(0x11), byte(0x12), byte(0x10), byte(0x04), byte(0x42), byte(0x1E), byte(0x55),
		byte(0x0B), byte(0x2E), byte(0xC3), byte(0x83), byte(0x10), byte(0xBA), byte(0x4E), byte(0x20),
		byte(0xDC), byte(0x84), byte(0x01), byte(0x23), byte(0x8D), byte(0xCC), byte(0x05), byte(0xE3),
		byte(0x21), byte(0x11), byte(0x02), byte(0x4C), byte(0xE4), byte(0x6F), byte(0x39), byte(0x22),
		byte(0x13), byte(0x20), byte(0xE3), byte(0x6F), byte(0x2C), byte(0x06), byte(0x04), byte(0x47),
		byte(0x23), byte(0xCE), byte(0x45), byte(0x39), byte(0x11), byte(0x44), byte(0xE4), byte(0x71),
		byte(0x10), byte(0x23), byte(0x91), byte(0x0F), byte(0x13), byte(0x96), byte(0x8C), byte(0x04),
		byte(0xC0), byte(0xBC), byte(0x03), byte(0xC4), byte(0x47), byte(0x31), byte(0xC4), byte(0x39),
		byte(0x16), byte(0x32), byte(0x3C), byte(0x00), byte(0x84), byte(0x91), byte(0x51), byte(0x11),
		byte(0x62), byte(0x53), byte(0x91), byte(0x33), byte(0x25), byte(0x0F), byte(0x3C), byte(0xE4),
		byte(0x53), byte(0x80), byte(0x24), byte(0xC8), byte(0x38), byte(0xDB), byte(0x85), byte(0x14),
		byte(0x80), byte(0x88), byte(0x00), byte(0xBD), byte(0x87), byte(0x39), byte(0x21), byte(0x28),
		byte(0x0C), byte(0x40), byte(0x27), byte(0x00), byte(0xF3), byte(0xD8), byte(0x9C), byte(0x40),
		byte(0x11), byte(0x4E), byte(0x11), byte(0x12), byte(0x4F), byte(0x31), byte(0x00), byte(0x32),
		byte(0xF4), byte(0x4E), byte(0x24), byte(0x40), byte(0x93), byte(0x9C), byte(0x84), byte(0xE1),
		byte(0x01), byte(0x21), byte(0x31), byte(0x10), byte(0xF4), byte(0x44), byte(0x48), byte(0x43),
		byte(0x53), byte(0xCC), byte(0xE5), byte(0x8D), byte(0xBD), byte(0x42), byte(0xCB), byte(0x85),
		byte(0x44), byte(0xAC), byte(0x00), byte(0xF8), byte(0xD1), byte(0x62), byte(0xC3), byte(0x8C),
		byte(0x88), byte(0x04), byte(0xE3), byte(0x00), byte(0x3C), byte(0x4E), byte(0x38), byte(0xCC),
		byte(0x8C), byte(0x20), byte(0xB1), byte(0x25), byte(0x20), byte(0x42), byte(0xC3), byte(0xA0),
		byte(0xC3), byte(0xC0), byte(0x09), byte(0x39), byte(0x54), byte(0x34), byte(0x3A), byte(0xC0),
		byte(0x44), byte(0x61), byte(0x23), byte(0x38), byte(0x69), byte(0xD4), byte(0x18), byte(0x4B),
		byte(0xD1), byte(0x10), byte(0xF0), byte(0x11), byte(0x12), byte(0x43), byte(0x55), byte(0x21),
		byte(0x13), byte(0x8D), byte(0x30), byte(0x43), byte(0x53), byte(0x00), byte(0xBB), byte(0xD1),
		byte(0x38), byte(0x35), byte(0x02), byte(0x12), byte(0x71), byte(0x11), byte(0x48), byte(0x42),
		byte(0xC5), byte(0xCC), byte(0x40), byte(0x02), byte(0x1E), byte(0xE2), byte(0x0B), byte(0xC9),
		byte(0x40), byte(0x87), byte(0xC8), byte(0x84), byte(0xD4), byte(0x01), byte(0x32), byte(0x0E),
		byte(0x37), byte(0x32), byte(0x04), byte(0x88), byte(0xE4), byte(0x93), byte(0xA0), byte(0xD0),
		byte(0xD4), byte(0x49), byte(0x34), byte(0x58), byte(0xC8), byte(0xA2), byte(0x0D), byte(0xC9),
		byte(0x34), byte(0x44), byte(0x11), byte(0x3A), byte(0x0C), byte(0x00), byte(0x61), byte(0x28),
		byte(0x4D), byte(0x21), byte(0x0B), byte(0x16), byte(0xF1), byte(0xCE), byte(0x34), byte(0x4B),
		byte(0xD1), byte(0x20), byte(0x21), byte(0x36), byte(0x10), byte(0x04), byte(0x6C), byte(0x39),
		byte(0x24), byte(0xF2), byte(0x50), byte(0xDC), byte(0x8E), byte(0x38), byte(0xD8), byte(0x8B),
		byte(0x10), byte(0x04), byte(0x6F), byte(0x44), byte(0x00), byte(0x93), byte(0x20), byte(0x21),
		byte(0x2F), byte(0x20), byte(0x40), byte(0x84), byte(0xD8), byte(0x02), byte(0x13), byte(0xC4),
		byte(0x40), byte(0x84), byte(0x35), byte(0x3A), byte(0x0C), byte(0x3C), byte(0xE4), byte(0x53),
		byte(0x00), byte(0xD4), byte(0xEF), byte(0x44), byte(0xE0), byte(0xD4), byte(0x09), byte(0x3A),
		byte(0xC4), byte(0x15), byte(0x3D), byte(0x80), byte(0x2C), byte(0xBC), byte(0x84), byte(0x44),
		byte(0x81), byte(0x12), byte(0xB4), byte(0x45), byte(0x92), byte(0xC8), byte(0x70), byte(0x11),
		byte(0x12), byte(0xC3), byte(0x95), byte(0x20), byte(0x4A), byte(0x88), byte(0x0E), byte(0xD3),
		byte(0x91), byte(0xC8), byte(0x83), byte(0x0F), byte(0x2D), byte(0x8D), byte(0x88), byte(0x14),
		byte(0x4B), byte(0x8D), byte(0x4C), byte(0xE8), byte(0x80), byte(0x4C), byte(0x21), byte(0xEC),
		byte(0x61), byte(0x21), byte(0x0B), byte(0x16), byte(0x52), byte(0x0D), byte(0x12), byte(0x23),
		byte(0x8C), byte(0x3D), byte(0x44), byte(0xC4), byte(0x47), byte(0x23), byte(0x8D), byte(0x1A),
		byte(0x04), byte(0xD3), byte(0x10), byte(0xD4), byte(0xC8), byte(0x38), byte(0xD8), byte(0xD1),
		byte(0x01), byte(0x69), byte(0x48), byte(0x2C), byte(0xCC), byte(0x44), byte(0x3D), byte(0x40),
		byte(0x4B), byte(0x20), byte(0x20), byte(0x0D), byte(0xC8), byte(0x40), byte(0x94), byte(0x44),
		byte(0x84), byte(0xD8), byte(0xC8), byte(0x23), byte(0x91), byte(0x13), byte(0x31), byte(0x12),
		byte(0x4F), byte(0x24), byte(0xCE), byte(0x08), byte(0xAB), byte(0xCE), byte(0x48), byte(0x84),
		byte(0xC8), byte(0x54), byte(0x48), byte(0x80), byte(0x51), byte(0x21), byte(0x22), byte(0x10),
		byte(0xD4), byte(0xD4), byte(0x45), byte(0x8D), byte(0x88), byte(0x34), byte(0x33), byte(0x96),
		byte(0xB0), byte(0x43), byte(0x0E), byte(0x45), byte(0x89), byte(0x17), byte(0x21), byte(0x24),
		byte(0xEB), byte(0x21), byte(0x24), byte(0xC4), byte(0x37), byte(0x24), byte(0xD1), byte(0x00),
		byte(0x81), byte(0x87), byte(0x4E), byte(0x25), byte(0x0B), byte(0x4D), byte(0x44), byte(0x44),
		byte(0x84), byte(0x82), byte(0xCB), byte(0x20), byte(0xE3), byte(0x65), byte(0x39), byte(0x13),
		byte(0x04), byte(0x46), byte(0x31), byte(0x02), byte(0x21), byte(0x22), byte(0x0E), byte(0x36),
		byte(0x43), byte(0x44), byte(0x44), byte(0x66), byte(0x2C), byte(0x39), byte(0x51), byte(0x32),
		byte(0x50), byte(0xC3), byte(0x04), byte(0x47), byte(0x63), byte(0x8D), byte(0x0C), byte(0x44),
		byte(0x71), byte(0x10), byte(0xB0), byte(0x13), byte(0x12), byte(0x05), byte(0x40), byte(0x20),
		byte(0xB0), byte(0x01), byte(0x2C), byte(0x4A), byte(0xC8), byte(0x34), byte(0x4A), byte(0xC8),
		byte(0x28), byte(0x42), byte(0xD8), byte(0xB9), byte(0x44), byte(0xD2), byte(0x20), byte(0x31),
		byte(0x32), byte(0x1C), byte(0xE4), byte(0xF2), byte(0x1C), byte(0xE4), byte(0x53), byte(0x88),
		byte(0xE5), byte(0x0D), byte(0x4D), byte(0x16), byte(0x31), byte(0x38), byte(0xB1), byte(0x20),
		byte(0x44), byte(0x40), byte(0x32), byte(0x20), byte(0xD1), byte(0x8B), byte(0x13), byte(0x15),
		byte(0x0B), byte(0x12), byte(0x30), byte(0x14), byte(0x18), byte(0x74), byte(0xC4), byte(0x46),
		byte(0xC0), byte(0x11), byte(0x28), byte(0x44), byte(0xE8), byte(0x34), byte(0x32), byte(0x02),
		byte(0x01), byte(0x31), byte(0x2F), byte(0x44), byte(0x44), byte(0x84), byte(0x35), byte(0x3A),
		byte(0xC0), byte(0x34), byte(0x38), byte(0x80), byte(0x30), byte(0xF0), byte(0x08), byte(0x18),
		byte(0xDB), byte(0x00), byte(0x4C), byte(0x44), byte(0x48), byte(0x00), byte(0xBB), byte(0xCE),
		byte(0x3D), byte(0x42), byte(0xC0), byte(0x4C), byte(0x83), byte(0x8D), byte(0x90), byte(0x23),
		byte(0x8D), byte(0x38), byte(0xC6), byte(0x2C), byte(0x10), byte(0x32), byte(0x02), byte(0x00),
		byte(0xB9), byte(0xCE), byte(0x48), byte(0xF2), byte(0x13), byte(0x00), byte(0xB8), byte(0x87),
		byte(0x51), byte(0x10), byte(0x87), byte(0x99), byte(0x13), byte(0x94), byte(0x34), byte(0x3C),
		byte(0xC7), byte(0x39), byte(0x44), byte(0x80), byte(0x34), byte(0x38), byte(0x14), byte(0x4C),
		byte(0x73), byte(0x91), byte(0x21), byte(0x36), byte(0x28), byte(0x35), byte(0x24), byte(0xC4),
		byte(0x00), byte(0x3C), byte(0x44), byte(0x08), byte(0x43), byte(0x53), byte(0x2D), byte(0x89),
		byte(0x54), byte(0x4D), byte(0x44), byte(0x44), byte(0xD9), byte(0x13), byte(0x8D), byte(0x1A),
		byte(0x83), byte(0x55), byte(0x38), byte(0xB5), byte(0x44), byte(0xAC), byte(0x81), byte(0x44),
		byte(0x9C), byte(0x42), byte(0x06), byte(0x1D), byte(0x3A), byte(0x0D), byte(0x09), byte(0x11),
		byte(0x00), byte(0x48), byte(0x4C), byte(0x48), byte(0x18), byte(0x74), byte(0xE1), byte(0x00),
		byte(0xD2), byte(0xA2), byte(0x50), byte(0xB4), byte(0xD4), byte(0x44), byte(0x02), byte(0xE2),
		byte(0x11), byte(0x14), byte(0xC0), byte(0x20), byte(0xD2), byte(0xD8), byte(0xD8), byte(0x44),
		byte(0x93), byte(0x91), byte(0x71), byte(0x02), byte(0x51), byte(0x32), byte(0x15), byte(0x12),
		byte(0x13), byte(0x80), byte(0x44), byte(0x3C), byte(0x84), byte(0x10), byte(0xAA), byte(0xCE),
		byte(0x34), byte(0x6B), byte(0x85), byte(0x14), byte(0x80), byte(0x84), byte(0x47), byte(0x24),
		byte(0xC0), byte(0x4C), byte(0x43), byte(0x04), byte(0x35), byte(0x3C), byte(0x44), byte(0x49),
		byte(0x38), byte(0x40), byte(0x62), byte(0x31), byte(0x00), byte(0x2F), byte(0x63), byte(0x91),
		byte(0x28), byte(0x44), byte(0x71), byte(0x11), byte(0x23), byte(0x94), byte(0x44), byte(0x21),
		byte(0x33), byte(0x1D), byte(0x13), byte(0x96), byte(0x94), byte(0xE4), byte(0x56), byte(0x01),
		byte(0x10), byte(0xEF), byte(0x38), byte(0xB2), byte(0x02), byte(0x63), byte(0x20), byte(0x88),
		byte(0x10), byte(0xD0), byte(0x84), byte(0x91), byte(0x81), byte(0x12), byte(0x84), byte(0x40),
		byte(0xE8), byte(0x4C), byte(0x43), byte(0x36), byte(0x10), byte(0x03), byte(0xCE), byte(0x36),
		byte(0x52), byte(0x0B), byte(0x2E), byte(0xF2), byte(0xC0), byte(0x36), byte(0xC2), byte(0x0B),
		byte(0x21), byte(0x30), byte(0x11), byte(0x62), byte(0x65), byte(0x0D), byte(0x9C), byte(0xE4),
		byte(0xE7), byte(0x10), byte(0x04), byte(0xE0), byte(0x0C), byte(0x34), byte(0x44), byte(0x49),
		byte(0x28), byte(0x8E), byte(0x2C), byte(0x39), byte(0x4E), byte(0x09), byte(0x44), byte(0xA5),
		byte(0x39), byte(0x11), byte(0x08), byte(0x18), byte(0xDC), byte(0xD1), byte(0x10), byte(0x04),
		byte(0xCC), byte(0x10), byte(0xD4), byte(0xE1), byte(0x2C), byte(0xE3), byte(0x83), byte(0xD0),
		byte(0xF3), byte(0x8D), byte(0x88), byte(0xE5), byte(0x11), byte(0x48), byte(0x4C), byte(0xC7),
		byte(0x21), byte(0x10), byte(0xF6), byte(0x01), byte(0x30), byte(0x87), byte(0x80), byte(0x51),
		byte(0x44), byte(0x09), byte(0x39), byte(0x00), byte(0x44), byte(0xB6), byte(0x32), byte(0x4C),
		byte(0xE4), byte(0x44), byte(0xCC), byte(0x75), byte(0x12), byte(0xC8), byte(0xE5), byte(0x0D),
		byte(0x0E), byte(0x45), byte(0x44), byte(0x45), byte(0x85), byte(0x87), byte(0x11), byte(0x11),
		byte(0x21), byte(0x00), byte(0x16), byte(0x20), byte(0x0C), byte(0xC2), byte(0x0D), byte(0x21),
		byte(0x24), byte(0xD1), byte(0x01), byte(0x32), byte(0x0E), byte(0x36), byte(0xC3), byte(0x94),
		byte(0x4C), byte(0x7B), byte(0xC0), byte(0x18), byte(0x49), byte(0x0D), byte(0x4C), byte(0x44),
		byte(0x6F), byte(0x44), byte(0xE0), byte(0x40), byte(0x04), byte(0xB6), byte(0x2F), byte(0x38),
		byte(0x83), byte(0x53), byte(0xC8), byte(0x40), byte(0x13), byte(0xB4), byte(0x04), byte(0xD4),
		byte(0x44), byte(0x02), byte(0xF1), byte(0x00), byte(0x21), byte(0x25), byte(0x01), byte(0x18),
		byte(0x87), byte(0x00), byte(0xB2), byte(0xC4), byte(0x34), byte(0x61), byte(0x2F), byte(0x01),
		byte(0x24), byte(0xA0), byte(0x3C), byte(0xF2), byte(0xD8), byte(0xB0), byte(0x02), byte(0x0B),
		byte(0xD1), byte(0x25), byte(0x00), byte(0x2C), byte(0xB6), byte(0x2C), byte(0x21), byte(0x7C),
		byte(0xCE), byte(0x50), byte(0x61), byte(0xE2), byte(0x2C), byte(0x40), byte(0x11), byte(0x2D),
		byte(0x89), byte(0x91), byte(0x39), byte(0x69), byte(0x40), byte(0x09), byte(0x33), byte(0x91),
		byte(0xC9), byte(0x30), byte(0x13), byte(0x12), byte(0xB3), byte(0x82), byte(0x00), byte(0xB9),
		byte(0x94), byte(0x62), byte(0x40), byte(0x12), byte(0x4F), byte(0x20), byte(0x15), byte(0x13),
		byte(0x23), byte(0x94), byte(0x4C), byte(0x7C), byte(0x82), byte(0x10), byte(0xD1), byte(0x2C),
		byte(0x39), byte(0x31), byte(0xC4), byte(0x46), byte(0x20), byte(0x11), byte(0x10), byte(0x44),
		byte(0x70), byte(0x50), byte(0x80), byte(0x8A), byte(0x2D), byte(0x88), byte(0x84), byte(0x35),
		byte(0x34), byte(0x40), byte(0x2E), byte(0x50), byte(0x02), byte(0x12), byte(0x80), byte(0x84),
		byte(0x80), byte(0x13), byte(0x95), byte(0x12), byte(0x11), byte(0x18), byte(0x38), byte(0xD0),
		byte(0xEF), byte(0x20), byte(0x24), byte(0xD4), byte(0x44), byte(0x4B), byte(0x44), byte(0x4D),
		byte(0x63), byte(0x91), byte(0x2A), byte(0xC0), byte(0x0D), byte(0x00), byte(0x61), byte(0x0C),
		byte(0x10), byte(0xD4), byte(0xE8), byte(0x34), byte(0x32), byte(0x15), byte(0x20), byte(0x35),
		byte(0x00), byte(0x2E), byte(0x50), byte(0x0D), byte(0xC8), byte(0x86), byte(0x44), byte(0xC8),
		byte(0xF1), byte(0x04), byte(0x0E), byte(0x15), byte(0x12), byte(0x63), byte(0x21), byte(0x11),
		byte(0x20), byte(0xE5), byte(0x12), byte(0xB8), byte(0x20), byte(0x94), byte(0x46), byte(0x00),
		byte(0xC3), byte(0xC4), byte(0x40), byte(0x03), byte(0x63), byte(0x22), byte(0x06), byte(0x36),
		byte(0x23), byte(0x8B), byte(0x2C), byte(0x40), byte(0x93), byte(0x20), byte(0xE3), byte(0x6B),
		byte(0x21), byte(0x24), byte(0xE0), byte(0x3C), byte(0xF4), byte(0x4E), byte(0x00), byte(0x21),
		byte(0xE2), byte(0x1C), byte(0x04), byte(0x46), byte(0x13), byte(0x05), byte(0x00), byte(0x2C),
		byte(0x84), byte(0xD8), byte(0xBD), byte(0x11), byte(0x12), byte(0x49), byte(0x44), byte(0x44),
		byte(0xD4), byte(0xE4), byte(0xC4), byte(0xB4), byte(0xE4), byte(0xC4), byte(0xBC), byte(0x04),
		byte(0x53), byte(0xC4), byte(0x40), byte(0x0B), byte(0xD8), byte(0x40), byte(0x62), byte(0x51),
		byte(0x14), byte(0x44), byte(0x35), byte(0x38), byte(0xC4), byte(0x4C), byte(0x44), byte(0x4C),
		byte(0x20), byte(0xD1), byte(0x33), byte(0x45), byte(0x41), byte(0x32), byte(0x00), byte(0x3D),
		byte(0x87), byte(0x01), byte(0x31), byte(0x15), byte(0x11), byte(0x18), byte(0x51), byte(0x10),
		byte(0x02), byte(0xB6), byte(0x39), byte(0x14), byte(0x58), byte(0x89), byte(0x43), byte(0xEF),
		byte(0x01), byte(0x14), byte(0xC8), byte(0x09), byte(0x42), byte(0xC0), byte(0x44), byte(0xB6),
		byte(0x20), byte(0x30), byte(0xE5), byte(0x0D), byte(0x4E), byte(0x00), byte(0x48), byte(0x2C),
		byte(0x84), byte(0xD8), byte(0x90), byte(0x04), byte(0xF1), byte(0x10), byte(0x23), byte(0x86),
		byte(0x34), byte(0x86), byte(0x44), byte(0xC8), byte(0x84), byte(0xE2), byte(0x1C), byte(0x04),
		byte(0x40), byte(0x09), byte(0x31), byte(0x11), byte(0xC8), byte(0xE3), byte(0x04), byte(0x04),
		byte(0xE0), byte(0xD8), byte(0xAC), byte(0xE4), byte(0x92), byte(0x8C), byte(0x41), byte(0x91),
		byte(0x10), byte(0x49), byte(0x05), byte(0x14), byte(0x40), byte(0x93), byte(0x81), byte(0x34),
		byte(0xC0), byte(0x08), byte(0xAC), byte(0x93), byte(0x00), byte(0x51), byte(0x6C), byte(0x20),
		byte(0x30), byte(0xCB), byte(0x13), byte(0x31), byte(0x0B), byte(0x11), byte(0x52), byte(0x12),
		byte(0x20), byte(0xE3), byte(0x76), byte(0x1D), byte(0x8A), byte(0xC4), byte(0x18), byte(0x02),
		byte(0xE2), byte(0x00), byte(0xF2), byte(0x13), byte(0x00), byte(0xBC), byte(0xD1), byte(0x00),
		byte(0x31), byte(0x24), byte(0x2C), byte(0x40), byte(0x93), byte(0x20), byte(0xE3), byte(0x64),
		byte(0x54), byte(0x44), byte(0x58), byte(0x04), byte(0xE0), byte(0xD8), byte(0x8D), byte(0x13),
		byte(0x8F), byte(0xB0), byte(0x02), byte(0x4E), byte(0x47), byte(0x52), byte(0x04), byte(0x5B),
		byte(0x24), byte(0xC0), byte(0x34), byte(0x30), byte(0x11), byte(0x0E), byte(0x12), byte(0x0B),
		byte(0x2E), byte(0x43), byte(0x0F), byte(0x2C), byte(0xE6), byte(0x04), byte(0x12), byte(0x32),
		byte(0x12), byte(0x09), byte(0x44), byte(0x92), byte(0x20), byte(0xE3), byte(0x6E), byte(0x3C),
		byte(0xF3), byte(0x91), byte(0x4D), byte(0x43), byte(0x48), byte(0x4D), byte(0x88), byte(0x0D),
		byte(0x00), byte(0xB6), byte(0x12), byte(0x21), byte(0x2C), byte(0xC4), byte(0x37), byte(0x25),
		byte(0x06), byte(0x18), byte(0x44), byte(0x93), byte(0xAC), byte(0x05), byte(0x98), byte(0x11),
		byte(0x19), byte(0xD4), byte(0x48), byte(0x10), byte(0x0D), byte(0x0F), byte(0x21), byte(0x02),
		byte(0x4C), byte(0x83), byte(0x8D), byte(0x84), byte(0x40), byte(0x8E), byte(0x30), byte(0x4C),
		byte(0x8A), byte(0x20), byte(0xB2), byte(0xF2), byte(0x21), byte(0x24), byte(0xC4), byte(0x47),
		byte(0x24), byte(0xD8), byte(0x2C), byte(0x48), byte(0x91), byte(0x20), byte(0xC1), byte(0x2F),
		byte(0x44), byte(0xE1), byte(0x91), byte(0x00), byte(0xC8), byte(0x8E), byte(0x30), byte(0xF0),
		byte(0x11), byte(0x12), byte(0x20), byte(0x0F), byte(0xB0), byte(0x84), byte(0x92), byte(0x84),
		byte(0x00), byte(0xF2), byte(0x39), byte(0x14), byte(0xF3), byte(0x44), byte(0x02), byte(0x0D),
		byte(0x20), byte(0xD1), byte(0xA4), byte(0x01), byte(0x26), byte(0x2D), byte(0x10), byte(0x04),
		byte(0x71), byte(0x10), byte(0x62), byte(0x0E), byte(0x37), byte(0x24), byte(0xD1), byte(0x01),
		byte(0x31), byte(0x06), byte(0x62), byte(0xF5), byte(0x11), byte(0x3C), byte(0xE4), byte(0x84),
		byte(0xBC), byte(0x44), byte(0x45), byte(0x39), byte(0x13), byte(0x33), byte(0x10), byte(0x21),
		byte(0xCD), byte(0x38), byte(0xB3), byte(0x86), byte(0x62), byte(0x40), byte(0x8E), byte(0x34),
		byte(0xE3), byte(0x08), byte(0x0A), byte(0x15), byte(0x03), byte(0x18), byte(0x44), byte(0xE4),
		byte(0x5C), byte(0x03), byte(0x0F), byte(0x2C), byte(0x48), byte(0x87), byte(0x10), byte(0x22),
		byte(0xA4), byte(0x35), byte(0x52), byte(0x11), byte(0x38), byte(0xD3), byte(0x04), byte(0x35),
		byte(0x3A), byte(0xC4), byte(0x1A), byte(0x30), byte(0x11), byte(0x2B), byte(0x31), byte(0x11),
		byte(0x33), byte(0x10), byte(0x13), byte(0x1C), byte(0x44), byte(0x6B), byte(0x01), byte(0x41),
		byte(0x87), byte(0x99), byte(0x41), byte(0x12), byte(0x4A), byte(0x20), byte(0x11), byte(0xAC),
		byte(0xE5), byte(0x84), byte(0x46), byte(0x70), byte(0x0D), byte(0x1A), byte(0xF0), byte(0x12),
		byte(0x4F), byte(0x23), byte(0x82), byte(0x20), byte(0x02), byte(0xE5), byte(0x39), byte(0x11),
		byte(0x84), byte(0x4E), byte(0x75), byte(0x0D), byte(0x0D), byte(0x11), byte(0x03), byte(0xC4),
		byte(0x43), byte(0x0E), byte(0x54), byte(0x4B), byte(0x00), byte(0x34), byte(0x01), byte(0x84),
		byte(0x46), byte(0x43), byte(0x49), byte(0x39), byte(0x89), byte(0x17), byte(0x00), byte(0x24),
		byte(0xCB), byte(0x62), byte(0x32), byte(0x04), byte(0x94), byte(0x83), byte(0x40), byte(0x2E),
		byte(0xC0), byte(0x18), byte(0x04), byte(0x49), byte(0xC4), byte(0x00), byte(0xB4), byte(0xC7),
		byte(0x94), byte(0xB3), byte(0x8E), byte(0x46), byte(0x21), byte(0xC0), byte(0x34), byte(0x61),
		byte(0x2B), byte(0x01), byte(0x8B), byte(0xCE), byte(0x39), byte(0x19), byte(0x54), byte(0x36),
		byte(0x44), byte(0x93), byte(0x00), byte(0x12), byte(0xC8), byte(0x48), byte(0x7C), byte(0xD1),
		byte(0x20), byte(0x02), byte(0xF2), byte(0x3D), byte(0x12), byte(0x0D), byte(0x1A), byte(0x32),
		byte(0x0D), byte(0x34), byte(0x44), byte(0x61), byte(0x20), byte(0x6C), byte(0xC7), byte(0x00),
		byte(0xD2), byte(0xAF), byte(0x44), byte(0xE4), byte(0xC4), byte(0x09), byte(0x38), byte(0x15),
		byte(0x38), byte(0x80), byte(0xE8), byte(0x30), byte(0x01), byte(0x88), byte(0x34), byte(0x4C),
		byte(0xCE), byte(0x34), byte(0x81), byte(0x87), byte(0x4F), byte(0x24), byte(0xC0), byte(0x46),
		byte(0x04), byte(0x4C), byte(0x94), byte(0x83), byte(0x48), byte(0x48), byte(0x7B), byte(0x14),
		byte(0x48), byte(0x80), byte(0xAE), byte(0x58), byte(0xD1), byte(0x11), byte(0x89), byte(0x16),
		byte(0x20), byte(0x45), byte(0x3B), byte(0xD1), byte(0x21), byte(0x50), byte(0x13), byte(0x12),
		byte(0xE4), byte(0xC7), byte(0x11), byte(0x14), byte(0xB2), byte(0x20), byte(0xC3), byte(0xCB),
		byte(0x12), byte(0xF3), byte(0x8F), byte(0x50), byte(0xB0), byte(0x11), byte(0xC4), byte(0x41),
		byte(0x4B), byte(0x10), byte(0x24), byte(0xE4), byte(0x48), byte(0xF1), byte(0x02), byte(0x20),
		byte(0x02), byte(0xCB), byte(0x63), byte(0x23), byte(0x00), byte(0x2C), byte(0xBA), byte(0xC8),
		byte(0x18), byte(0x74), byte(0xEC), byte(0x11), byte(0x24), byte(0x80), byte(0x18), byte(0x4C),
		byte(0x93), byte(0x10), byte(0xFA), byte(0x84), byte(0x62), byte(0xF1), byte(0x00), byte(0x08),
		byte(0x4B), byte(0xD1), byte(0x38), byte(0x64), byte(0x44), byte(0x49), byte(0x28), byte(0x40),
		byte(0x37), byte(0x22), byte(0x03), byte(0x12), byte(0x64), byte(0x44), byte(0x01), byte(0x39),
		byte(0x48), byte(0x5E), byte(0x83), byte(0x53), byte(0x11), byte(0x15), byte(0x48), byte(0x11),
		byte(0x6B), byte(0x00), byte(0x34), byte(0x01), byte(0x84), byte(0xB4), byte(0x04), byte(0xC8),
		byte(0x38), byte(0xD0), byte(0x0B), byte(0x94), byte(0x84), byte(0x87), byte(0xAC), byte(0xE4),
		byte(0x84), byte(0x88), byte(0x03), byte(0x04), byte(0x44), byte(0x08), byte(0xC8), byte(0x48),
		byte(0x25), byte(0x12), byte(0x4A), byte(0x44), byte(0x14), byte(0x00), byte(0xBD), byte(0x84),
		byte(0x20), byte(0x61), byte(0xD3), byte(0xBC), byte(0x44), byte(0x45), byte(0x39), byte(0x13),
		byte(0x00), byte(0x34), byte(0x21), byte(0x32), byte(0x11), byte(0x51), byte(0x0D), byte(0xD8),
		byte(0x04), byte(0xC4), byte(0x46), byte(0xF4), byte(0x4E), byte(0x0D), byte(0x40), byte(0x93),
		byte(0x20), byte(0xE3), byte(0x6F), byte(0x11), byte(0x14), byte(0x8E), byte(0x34), byte(0x02),
		byte(0xE2), byte(0x10), byte(0xB2), byte(0xEF), byte(0x39), byte(0x61), byte(0x11), byte(0x91),
		byte(0x51), byte(0x0D), byte(0x20), byte(0xD1), byte(0xA2), byte(0x38), byte(0xB3), byte(0x91),
		byte(0xA0), byte(0xD4), byte(0x88), byte(0x0C), byte(0x48), byte(0x40), byte(0x47), byte(0x43),
		byte(0x48), byte(0x4E), byte(0xB1), byte(0x12), byte(0x4A), byte(0x00), byte(0xD4), byte(0x2D),
		byte(0x3D), byte(0x88), byte(0x0C), byte(0x4C), byte(0x40), byte(0x34), byte(0x61), byte(0x2C),
		byte(0x10), byte(0xD4), byte(0xC8), byte(0x38), byte(0xD8), byte(0xC4), byte(0x10), byte(0xF9),
		byte(0x03), byte(0x18), byte(0x4C), byte(0x93), byte(0x44), byte(0xE3), byte(0x46), byte(0x9C),
		byte(0x04), byte(0x43), byte(0xCD), byte(0x13), byte(0x94), byte(0x04), byte(0xB1), byte(0x2D),
		byte(0x10), byte(0x21), byte(0x12), byte(0x48), byte(0x04), byte(0x58), byte(0xC8), byte(0x01),
		byte(0x44), byte(0x88), byte(0xE3), byte(0x0C), byte(0x38), byte(0xD9), byte(0x44), byte(0x01),
		byte(0x19), byte(0x40), byte(0x30), byte(0x82), byte(0xD8), byte(0xC8), byte(0x40), byte(0x23),
		byte(0x44), byte(0x40), byte(0x0C), byte(0x88), byte(0xE3), byte(0x45), byte(0x11), byte(0x11),
		byte(0x0D), byte(0x08), byte(0x4C), byte(0x44), byte(0x3C), byte(0xB6), byte(0x2F), byte(0x44),
		byte(0xE3), byte(0xC4), byte(0x45), byte(0x36), byte(0x2C), byte(0x10), byte(0x44), byte(0xC8),
		byte(0x34), byte(0x68), byte(0x0B), byte(0x58), byte(0x06), byte(0x12), byte(0xC9), byte(0x35),
		byte(0x05), byte(0x16), byte(0x01), byte(0x84), byte(0x34), byte(0x26), byte(0x23), byte(0x10),
		byte(0x04), byte(0xC7), byte(0x99), byte(0x13), byte(0x96), byte(0x4C), byte(0x7C), byte(0x84),
		byte(0x2C), byte(0xBC), byte(0x8E), byte(0x2C), byte(0x32), byte(0x04), byte(0x46), byte(0x00),
		byte(0x93), byte(0x9C), byte(0x40), byte(0x15), byte(0x63), byte(0x61), byte(0x13), byte(0x84),
		byte(0x01), byte(0xAC), byte(0x01), byte(0x14), byte(0x48), byte(0x00), byte(0x61), byte(0x23),
		byte(0x10), byte(0x00), byte(0xF2), byte(0x20), byte(0xD1), byte(0xB1), byte(0x21), byte(0x21),
		byte(0x23), byte(0x10), byte(0x20), byte(0x03), byte(0x13), byte(0x61), byte(0xCE), byte(0x32),
		byte(0x52), byte(0x06), byte(0x51), byte(0x11), byte(0x2F), byte(0x38), byte(0xB2), byte(0x02),
		byte(0x12), byte(0x13), byte(0x83), byte(0x62), byte(0xC0), byte(0x02), byte(0x1C), byte(0x83),
		byte(0x44), byte(0x88), byte(0x04), byte(0xC4), byte(0x18), byte(0xE4), byte(0x58), byte(0x80),
		byte(0x71), byte(0x00), byte(0x0E), byte(0x54), byte(0x4E), byte(0x35), byte(0x38), byte(0x80),
		byte(0x44), byte(0x4B), byte(0x91), byte(0x0C), byte(0x44), byte(0x71), byte(0x10), byte(0x02),
		byte(0xC8), byte(0x4D), byte(0x8B), byte(0xC0), byte(0x45), byte(0x33), byte(0x44), byte(0x47),
		byte(0x80), byte(0x11), byte(0x0E), byte(0x11), byte(0x00), byte(0x4F), byte(0x52), byte(0x0E),
		byte(0x2C), byte(0x43), byte(0x42), byte(0x13), byte(0x33), byte(0x93), byte(0x00), byte(0xB8),
		byte(0xC4), byte(0x14), byte(0x43), byte(0x52), byte(0x13), byte(0x64), byte(0x48), byte(0x4C),
		byte(0x48), byte(0x8E), byte(0x35), byte(0x25), byte(0x0C), byte(0x11), byte(0x18), byte(0x84),
		byte(0x35), byte(0x31), byte(0x11), byte(0x99), byte(0x13), byte(0x94), byte(0x3F), byte(0x31),
		byte(0xCE), byte(0x50), byte(0x61), byte(0xD3), byte(0xB0), byte(0xE0), byte(0xC4), byte(0x44),
		byte(0xDC), byte(0xC0), byte(0x48), byte(0xA8), byte(0x8E), byte(0x00), byte(0x21), byte(0xF1),
		byte(0x10), byte(0x04), byte(0x8E), byte(0x36), byte(0x01), byte(0x84), byte(0x94), byte(0x83),
		byte(0x46), byte(0x11), byte(0x1C), byte(0x8F), byte(0x10), byte(0x22), byte(0x05), byte(0x20),
		byte(0x28), byte(0x8E), byte(0x34), byte(0xD1), byte(0x02), byte(0x4C), byte(0x83), byte(0x8D),
		byte(0xD8), byte(0x84), byte(0x87), byte(0xC4), byte(0x44), byte(0x8F), byte(0x38), byte(0xD4),
		byte(0x84), byte(0xBD), byte(0x11), byte(0x13), byte(0x4D), byte(0x8B), byte(0x0E), byte(0x54),
		byte(0x43), byte(0x04), byte(0x35), byte(0x38), byte(0x80), byte(0x44), byte(0x3A), byte(0xCE),
		byte(0x1A), byte(0xF1), byte(0x0D), byte(0xC9), byte(0x43), byte(0x33), byte(0x44), byte(0x41),
		byte(0x24), byte(0x35), byte(0x32), byte(0x11), byte(0x12), byte(0x22), byte(0x13), byte(0x21),
		byte(0x91), byte(0x0D), byte(0xCC), byte(0x74), byte(0x4E), byte(0x50), byte(0x61), byte(0xCE),
		byte(0x51), byte(0x3B), byte(0xC4), byte(0x4F), byte(0x22), byte(0x0C), byte(0x20), byte(0xB0),
		byte(0x11), byte(0xD4), byte(0x80), byte(0x93), byte(0x20), byte(0xCB), byte(0x44), byte(0x59),
		byte(0x23), byte(0xC0), byte(0x3C), byte(0x44), byte(0x73), byte(0x1D), byte(0x11), byte(0x00),
		byte(0x4E), byte(0x22), byte(0xC0), byte(0x49), byte(0x2C), byte(0x87), byte(0x00), byte(0xA1),
		byte(0x32), byte(0x39), byte(0x44), byte(0x42), byte(0x12), byte(0x00), byte(0x82), byte(0x39),
		byte(0x43), byte(0x53), byte(0xBC), byte(0x02), byte(0x0D), byte(0x94), byte(0x02), byte(0xCB),
		byte(0xC4), byte(0x80), byte(0x87), byte(0xBC), byte(0xE4), byte(0x92), byte(0x20), byte(0x12),
		byte(0xC4), byte(0x80), byte(0x20), byte(0x84), byte(0x3D), byte(0x3C), byte(0x8E), byte(0x2C),
		byte(0x80), byte(0xF3), byte(0x44), byte(0x05), byte(0x44), byte(0x2F), byte(0x30), byte(0x0B),
		byte(0x2B), byte(0x22), byte(0x98), byte(0x89), byte(0x11), byte(0x00), byte(0x4C), byte(0x4B),
		byte(0x4E), byte(0x34), byte(0x4B), byte(0xCB), byte(0x10), byte(0xD4), byte(0xD8), byte(0xBC),
		byte(0x44), byte(0x48), byte(0x38), byte(0x38), byte(0xC4), byte(0x14), byte(0x83), byte(0x44),
		byte(0xB4), byte(0xE4), byte(0x4C), byte(0x00), byte(0xBC), byte(0x44), byte(0x54), byte(0x40),
		byte(0x0B), byte(0x8D), byte(0x12), byte(0x0D), byte(0x2A), byte(0x05), byte(0x13), byte(0x1C),
		byte(0xE4), byte(0x72), byte(0x11), byte(0x15), byte(0x44), byte(0xB4), byte(0x03), byte(0x04),
		byte(0xB0), byte(0xE3), byte(0x04), byte(0x35), byte(0x38), byte(0x06), byte(0x10), byte(0xD4),
		byte(0xE3), byte(0x38), byte(0x25), byte(0x0C), byte(0x10), byte(0xD4), byte(0xE0), byte(0x09),
		byte(0x32), byte(0x15), byte(0x21), byte(0x36), byte(0x20), byte(0x35), byte(0x85), byte(0x80),
		byte(0x62), byte(0x01), byte(0x51), byte(0x00), byte(0x80), byte(0xF3), byte(0x60), byte(0xF1),
		byte(0x20), byte(0x09), byte(0x32), byte(0x15), byte(0x13), byte(0x34), byte(0x40), byte(0x20),
		byte(0xDA), byte(0x0D), byte(0x4C), byte(0x44), byte(0x44), byte(0x49), byte(0x32), byte(0x0D),
		byte(0x1B), byte(0x10), byte(0x03), byte(0x20), byte(0xE8), byte(0xC0), byte(0x34), byte(0x61),
		byte(0x11), byte(0x98), byte(0x43), byte(0x44), byte(0x44), byte(0x04), byte(0xC8), byte(0x38),
		byte(0xDA), byte(0xC4), byte(0x00), byte(0x58), byte(0x8E), byte(0x3D), byte(0x8B), byte(0x00),
		byte(0x4C), byte(0x21), byte(0xE2), byte(0x2C), byte(0x02), byte(0x0C), byte(0x80), byte(0xD6),
		byte(0x0E), byte(0x34), byte(0x4C), byte(0x8E), byte(0x15), byte(0x35), byte(0x80), byte(0x44),
		byte(0x4B), byte(0xC0), byte(0x45), byte(0x36), byte(0x23), byte(0x11), byte(0x52), byte(0x02),
		byte(0x12), byte(0x23), byte(0x83), byte(0x12), byte(0xB0), byte(0x0D), byte(0x19), byte(0x40),
		byte(0x06), byte(0x12), byte(0xB2), byte(0x0D), byte(0x2A), byte(0x73), byte(0x96), byte(0x11),
		byte(0x51), byte(0x11), byte(0x88), byte(0xE3), byte(0x45), byte(0x21), byte(0x13), byte(0x22),
		byte(0x38), byte(0xC3), byte(0x04), byte(0x35), byte(0x38), byte(0x88), byte(0x4D), byte(0x88),
		byte(0x0D), byte(0x61), byte(0x61), byte(0xC4), byte(0x44), byte(0x4C), byte(0x8E), byte(0x30),
		byte(0x45), byte(0x84), byte(0x1C), byte(0x44), byte(0x44), byte(0x8C), byte(0x40), byte(0x40),
		byte(0x4C), byte(0x48), byte(0xD1), byte(0x21), byte(0x51), byte(0x27), byte(0x20), byte(0x61),
		byte(0xC4), byte(0x46), byte(0x11), byte(0x00), byte(0x51), byte(0x32), byte(0x05), byte(0x50),
		byte(0xBB), byte(0x8D), byte(0x2C), byte(0x83), byte(0x44), byte(0xD8), byte(0xE3), byte(0x00),
		byte(0x36), byte(0xF4), byte(0x48), byte(0x39), byte(0x12), byte(0x13), byte(0x63), byte(0x34),
		byte(0x40), byte(0x0C), byte(0x84), byte(0xC8), byte(0x38), byte(0xD0), byte(0x0B), byte(0x94),
		byte(0xE5), byte(0x11), byte(0x94), byte(0x83), byte(0x40), byte(0x34), byte(0x22), byte(0x00),
		byte(0x2D), byte(0xE7), byte(0x9E),
	}
)

func NewTextCodec(args ...int) (*TextCodec, error) {
	dictSize := TC_THRESHOLD2 * 4

	if len(args) == 1 {
		dictSize = args[0]
	}

	return NewTextCodecWithArgs(dictSize, nil, TC_LOG_HASHES_SIZE)
}

// dictSize (in words) = number of dictionary entries
func NewTextCodecWithArgs(dictSize int, dict []byte, logHashSize uint) (*TextCodec, error) {
	if logHashSize < 10 || logHashSize > 28 {
		return nil, errors.New("The hash table size log must be in [10..28]")
	}

	if dictSize < TC_STATIC_DICT_WORDS+128 || dictSize > 1<<logHashSize {
		return nil, fmt.Errorf("The number of words in the dictionary must be in [%v..%v]",
			TC_STATIC_DICT_WORDS+128, 1<<logHashSize)
	}

	this := new(TextCodec)
	this.logHashSize = uint(logHashSize)
	this.dictSize = dictSize
	this.dictMap = make([]*DictEntry, 1<<this.logHashSize)
	this.dictList = make([]DictEntry, this.dictSize)
	this.hashMask = int32(1<<this.logHashSize) - 1
	this.freqs = make([]int, 256*257)
	nbWords := 0

	// Replace default dictionary ?
	if dict != nil && &dict != &TC_DICT_EN_1024 {
		// Keep at least 20% space for dynamic dictionary
		nbWords = createDictionary(dict, this.dictList, this.dictSize*4/5, 0)
	} else {
		size := len(TC_STATIC_DICTIONARY)

		if size >= this.dictSize {
			size = this.dictSize
		}

		copy(this.dictList, TC_STATIC_DICTIONARY[0:size])
		nbWords = TC_STATIC_DICT_WORDS
	}

	// Add special entries at end of static dictionary
	this.dictList[nbWords] = DictEntry{buf: []byte{TC_ESCAPE_TOKEN2}, pos: 0, hash: 0, idx: int32(nbWords), length: int16(1)}
	this.dictList[nbWords+1] = DictEntry{buf: []byte{TC_ESCAPE_TOKEN1}, pos: 0, hash: 0, idx: int32(nbWords + 1), length: int16(1)}
	this.staticDictSize = nbWords + 2
	return this, nil
}

func NewTextCodecFromMap(ctx map[string]interface{}) (*TextCodec, error) {
	this := new(TextCodec)

	// Actual block size
	blockSize := ctx["size"].(uint)
	var log uint32

	if blockSize >= 1<<28 {
		log = 28
	} else if blockSize < 1<<10 {
		log = 10
	} else {
		log, _ = kanzi.Log2(uint32(3 * blockSize / 2))
	}

	// Select an appropriate initial dictionary size
	dSize := 1 << 12

	for i := uint(14); i <= 24; i += 2 {
		if blockSize >= 1<<i {
			dSize <<= 1
		}
	}

	extraPerf := false
	extraMem := uint(0)

	if _, containsKey := ctx["extra"]; containsKey {
		extraPerf = ctx["extra"].(bool)
	}

	if extraPerf == true {
		extraMem = 1
	}

	this.logHashSize = uint(log) + extraMem
	this.dictSize = dSize
	this.dictMap = make([]*DictEntry, 1<<this.logHashSize)
	this.dictList = make([]DictEntry, this.dictSize)
	this.hashMask = int32(1<<this.logHashSize) - 1
	this.freqs = make([]int, 256*257)
	size := len(TC_STATIC_DICTIONARY)

	if size >= this.dictSize {
		size = this.dictSize
	}

	copy(this.dictList, TC_STATIC_DICTIONARY[0:size])
	nbWords := TC_STATIC_DICT_WORDS

	// Add special entries at end of static dictionary
	this.dictList[nbWords] = DictEntry{buf: []byte{TC_ESCAPE_TOKEN2}, pos: 0, hash: 0, idx: int32(nbWords), length: int16(1)}
	this.dictList[nbWords+1] = DictEntry{buf: []byte{TC_ESCAPE_TOKEN1}, pos: 0, hash: 0, idx: int32(nbWords + 1), length: int16(1)}
	this.staticDictSize = nbWords + 2
	return this, nil
}

func initDelimiterChars() []bool {
	res := make([]bool, 256)

	for i := range res {
		if (i >= ' ') && (i <= '/') { // [ !"#$%&'()*+,-./]
			res[i] = true
		} else if (i >= ':') && (i <= '?') { // [:;<=>?]
			res[i] = true
		} else {
			switch i {
			case '\n':
				fallthrough
			case '\r':
				fallthrough
			case '\t':
				fallthrough
			case '_':
				fallthrough
			case '|':
				fallthrough
			case '{':
				fallthrough
			case '}':
				fallthrough
			case '[':
				fallthrough
			case ']':
				res[i] = true
			default:
				res[i] = false
			}
		}
	}

	return res
}

func initTextChars() []bool {
	res := make([]bool, 256)

	for i := range res {
		res[i] = isLowerCase(byte(i)) || isUpperCase(byte(i))
	}

	return res
}

func (this *TextCodec) Forward(src, dst []byte) (uint, uint, error) {
	if src == nil {
		return uint(0), uint(0), errors.New("Invalid nil source buffer")
	}

	if dst == nil {
		return uint(0), uint(0), errors.New("Invalid nil destination buffer")
	}

	if kanzi.SameByteSlices(src, dst, false) {
		return 0, 0, errors.New("Input and output buffers cannot be equal")
	}

	count := len(src)

	if n := this.MaxEncodedLen(count); len(dst) < n {
		return 0, 0, fmt.Errorf("Output buffer is too small - size: %d, required %d", len(dst), n)
	}

	srcIdx := 0
	dstIdx := 0

	if count <= 16 {
		for i := 0; i < count; i++ {
			dst[dstIdx] = src[srcIdx]
			srcIdx++
			dstIdx++
		}

		return uint(srcIdx), uint(dstIdx), nil
	}

	// Populate hash map
	for i := 0; i < this.staticDictSize; i++ {
		e := this.dictList[i]
		this.dictMap[e.hash&this.hashMask] = &e
	}

	// Pre-allocate all dictionary entries
	for i := this.staticDictSize; i < this.dictSize; i++ {
		this.dictList[i] = DictEntry{buf: nil, pos: -1, hash: 0, idx: int32(i), length: int16(0)}
	}

	srcEnd := count
	dstEnd := this.MaxEncodedLen(count)
	dstEnd3 := dstEnd - 3
	var delimAnchor int // previous delimiter

	if isText(src[srcIdx]) {
		delimAnchor = srcIdx - 1
	} else {
		delimAnchor = srcIdx
	}

	emitAnchor := 0 // never negative
	words := this.staticDictSize
	mode := computeStats(src[srcIdx:srcIdx+count], this.freqs)

	// Not text ?
	if mode&0x80 != 0 {
		return uint(srcIdx), uint(dstIdx), errors.New("Input is not text, skipping")
	}

	// DOS encoded end of line (CR+LF) ?
	this.isCRLF = mode&0x01 != 0
	dst[dstIdx] = mode
	dstIdx++

	if src[srcIdx] == ' ' {
		dst[dstIdx] = ' '
		srcIdx++
		dstIdx++
		emitAnchor++
	}

	for srcIdx < srcEnd && dstIdx < dstEnd {
		cur := src[srcIdx]

		if isText(cur) {
			srcIdx++
			continue
		}

		if (srcIdx > delimAnchor+2) && (isDelimiter(cur)) { // At least 2 letters
			// Compute hashes
			// h1 -> hash of word chars
			// h2 -> hash of word chars with first char case flipped
			val := src[delimAnchor+1]
			var caseFlag int32

			if isUpperCase(val) {
				caseFlag = 32
			} else {
				caseFlag = -32
			}

			h1 := TC_HASH1
			h2 := TC_HASH1
			h1 = h1*TC_HASH1 ^ int32(val)*TC_HASH2
			h2 = h2*TC_HASH1 ^ (int32(val)+caseFlag)*TC_HASH2

			for i := delimAnchor + 2; i < srcIdx; i++ {
				h := int32(src[i]) * TC_HASH2
				h1 = h1*TC_HASH1 ^ h
				h2 = h2*TC_HASH1 ^ h
			}

			// Check word in dictionary
			length := srcIdx - delimAnchor - 1
			pe1 := this.dictMap[h1&this.hashMask]
			var pe2 *DictEntry = nil

			// Check for hash collisions
			if (pe1 != nil) && (pe1.length != int16(length) || pe1.hash != h1) {
				pe1 = nil
			}

			if pe1 == nil {
				pe2 = this.dictMap[h2&this.hashMask]

				if (pe2 != nil) && (pe2.length != int16(length) || pe2.hash != h2) {
					pe2 = nil
				}
			}

			var pe *DictEntry

			if pe1 != nil {
				pe = pe1
			} else {
				pe = pe2
			}

			if pe != nil {
				if !sameWords(pe.buf[pe.pos+1:pe.pos+length], src[delimAnchor+2:srcEnd]) {
					pe = nil
				}
			}

			if pe == nil {
				// Word not found in the dictionary or hash collision: add or replace word
				if ((length > 3) || (length > 2 && words < TC_THRESHOLD2)) && length < TC_MAX_WORD_LENGTH {
					pe := &this.dictList[words]
					peidx := int(pe.idx)

					if peidx >= this.staticDictSize {
						// Evict and reuse old entry
						this.dictMap[pe.hash&this.hashMask] = nil
						pe.buf = src
						pe.pos = delimAnchor + 1
						pe.hash = h1
						pe.idx = int32(words)
						pe.length = int16(length)
					}

					// Update hash map
					this.dictMap[h1&this.hashMask] = pe
					words++

					// Dictionary full ? Expand or reset index to end of static dictionary
					if words >= this.dictSize {
						if this.expandDictionary() == false {
							words = this.staticDictSize
						}
					}
				}
			} else {
				// Word found in the dictionary
				// Skip space if only delimiter between 2 word references
				if (emitAnchor != delimAnchor) || (src[delimAnchor] != ' ') {
					dstIdx += this.emitSymbols(src[emitAnchor:delimAnchor+1], dst[dstIdx:dstEnd])
				}

				emitAnchor = delimAnchor + 1

				if dstIdx >= dstEnd3 {
					break
				}

				if pe == pe1 {
					dst[dstIdx] = TC_ESCAPE_TOKEN1
				} else {
					dst[dstIdx] = TC_ESCAPE_TOKEN2
				}

				dstIdx++
				dstIdx += emitWordIndex(dst[dstIdx:dstIdx+3], int(pe.idx))
				emitAnchor += int(pe.length)
			}
		}

		// Reset delimiter position
		delimAnchor = srcIdx
		srcIdx++
	}

	// Emit last symbols
	dstIdx += this.emitSymbols(src[emitAnchor:srcEnd], dst[dstIdx:dstEnd])

	err := error(nil)

	if srcIdx != srcEnd {
		err = fmt.Errorf("Forward transform failed. Source index: %v, expected: %v", srcIdx, srcEnd)
	}

	return uint(srcIdx), uint(dstIdx), err
}

// return status (8 bits):
// 0x80 => not text
// 0x01 => CR+LF transform
func computeStats(block []byte, freqs []int) byte {
	for i := range freqs {
		freqs[i] = 0
	}

	prv := byte(0)
	freqs1 := freqs[0:65536]
	freqs0 := freqs[65536:]
	freqs0[block[0]]++
	freqs1[block[0]]++

	for i := 1; i < len(block); i++ {
		freqs0[block[i]]++
		freqs1[(int(prv)<<8)+int(block[i])]++
		prv = block[i]
	}

	nbTextChars := 0

	for i := 32; i < 128; i++ {
		if isText(byte(i)) {
			nbTextChars += freqs0[i]
		}
	}

	// Not text
	if 2*nbTextChars < len(block) {
		return 0x80
	}

	nbBinChars := 0

	for i := 128; i < 256; i++ {
		nbBinChars += freqs0[i]
	}

	// Not text
	if 4*nbBinChars > len(block) {
		return 0x80
	}

	// Check CR+LF matches
	res := byte(0)

	if (freqs0[CR] != 0) && (freqs0[CR] == freqs0[LF]) {
		res = 1
		base := int(CR) << 8

		for i := 0; i < 256; i++ {
			if (i != int(LF)) && (freqs1[base+i] != 0) {
				res = 0
				break
			}
		}
	}

	return res
}

func (this *TextCodec) expandDictionary() bool {
	if this.dictSize >= TC_MAX_DICT_SIZE {
		return false
	}

	newDict := make([]DictEntry, this.dictSize*2)
	copy(newDict, this.dictList)

	for i := this.dictSize; i < this.dictSize*2; i++ {
		newDict[i] = DictEntry{buf: nil, pos: -1, hash: 0, idx: int32(i), length: int16(0)}
	}

	this.dictList = newDict
	this.dictSize <<= 1
	return true
}

func (this *TextCodec) emitSymbols(src, dst []byte) int {
	dstIdx := 0
	dstEnd := len(dst)

	for i := range src {
		if dstIdx >= dstEnd {
			break
		}

		cur := src[i]

		switch cur {
		case TC_ESCAPE_TOKEN1:
			fallthrough
		case TC_ESCAPE_TOKEN2:
			// Emit special word
			dst[dstIdx] = TC_ESCAPE_TOKEN1
			dstIdx++
			var idx int
			lenIdx := 2

			if cur == TC_ESCAPE_TOKEN1 {
				idx = this.staticDictSize - 1
			} else {
				idx = this.staticDictSize - 2
			}

			if idx >= TC_THRESHOLD2 {
				lenIdx = 3
			} else if idx < TC_THRESHOLD1 {
				lenIdx = 1
			}

			if dstIdx+lenIdx < dstEnd {
				dstIdx += emitWordIndex(dst[dstIdx:dstIdx+lenIdx], idx)
			}

		case CR:
			if this.isCRLF == false {
				dst[dstIdx] = cur
				dstIdx++
			}

		default:
			dst[dstIdx] = cur
			dstIdx++
		}
	}

	return dstIdx
}

func emitWordIndex(dst []byte, val int) int {
	// Emit word index (varint 5 bits + 7 bits + 7 bits)
	if val >= TC_THRESHOLD1 {
		dstIdx := 0

		if val >= TC_THRESHOLD2 {
			dst[dstIdx] = byte(0xE0 | (val >> 14))
			dstIdx++
		}

		dst[dstIdx] = byte(0x80 | (val >> 7))
		dst[dstIdx+1] = byte(0x7F & val)
		return dstIdx + 2
	}

	dst[0] = byte(val)
	return 1
}

func sameWords(buf, src []byte) bool {
	// Skip first position (same result)
	for i := range buf {
		if buf[i] != src[i] {
			return false
		}
	}

	return true
}

func (this *TextCodec) Inverse(src, dst []byte) (uint, uint, error) {
	if src == nil {
		return uint(0), uint(0), errors.New("Invalid nil source buffer")
	}

	if dst == nil {
		return uint(0), uint(0), errors.New("Invalid nil destination buffer")
	}

	if kanzi.SameByteSlices(src, dst, false) {
		return 0, 0, errors.New("Input and output buffers cannot be equal")
	}

	srcIdx := 0
	dstIdx := 0
	count := len(src)

	if count <= 16 {
		for i := 0; i < count; i++ {
			dst[dstIdx] = src[srcIdx]
			srcIdx++
			dstIdx++
		}

		return uint(srcIdx), uint(dstIdx), nil
	}

	// Populate hash map
	for i := 0; i < this.staticDictSize; i++ {
		e := this.dictList[i]
		this.dictMap[e.hash&this.hashMask] = &e
	}

	// Pre-allocate all dictionary entries
	for i := this.staticDictSize; i < this.dictSize; i++ {
		this.dictList[i] = DictEntry{buf: nil, pos: -1, hash: 0, idx: int32(i), length: int16(0)}
	}

	srcEnd := len(src)
	dstEnd := len(dst)
	var delimAnchor int // previous delimiter

	if isText(src[srcIdx]) {
		delimAnchor = srcIdx - 1
	} else {
		delimAnchor = srcIdx
	}

	words := this.staticDictSize
	wordRun := false
	err := error(nil)
	this.isCRLF = src[srcIdx]&0x01 != 0
	srcIdx++

	for srcIdx < srcEnd && dstIdx < dstEnd {
		cur := src[srcIdx]

		if isText(cur) {
			dst[dstIdx] = cur
			srcIdx++
			dstIdx++
			continue
		}

		if (srcIdx > delimAnchor+2) && isDelimiter(cur) {
			h1 := TC_HASH1

			for i := delimAnchor + 1; i < srcIdx; i++ {
				h1 = h1*TC_HASH1 ^ int32(src[i])*TC_HASH2
			}

			// Lookup word in dictionary
			length := srcIdx - delimAnchor - 1
			pe := this.dictMap[h1&this.hashMask]

			// Check for hash collisions
			if pe != nil {
				if pe.length != int16(length) || pe.hash != h1 {
					pe = nil
				} else if !sameWords(pe.buf[pe.pos+1:pe.pos+length], src[delimAnchor+2:delimAnchor+2+length]) {
					pe = nil
				}
			}

			if pe == nil {
				// Word not found in the dictionary or hash collision: add or replace word
				if ((length > 3) || (length > 2 && words < TC_THRESHOLD2)) && length < TC_MAX_WORD_LENGTH {
					pe = &this.dictList[words]
					peidx := int(pe.idx)

					if peidx >= this.staticDictSize {
						// Evict and reuse old entry
						this.dictMap[pe.hash&this.hashMask] = nil
						pe.buf = src
						pe.pos = delimAnchor + 1
						pe.hash = h1
						pe.idx = int32(words)
						pe.length = int16(length)
					}

					this.dictMap[h1&this.hashMask] = pe
					words++

					// Dictionary full ? Expand or reset index to end of static dictionary
					if words >= this.dictSize {
						if this.expandDictionary() == false {
							words = this.staticDictSize
						}
					}
				}
			}
		}

		srcIdx++

		if cur == TC_ESCAPE_TOKEN1 || cur == TC_ESCAPE_TOKEN2 {
			// Word in dictionary
			// Read word index (varint 5 bits + 7 bits + 7 bits)
			idx := int(src[srcIdx])
			srcIdx++

			if idx >= 0x80 {
				idx &= 0x7F
				idx2 := int(src[srcIdx])
				srcIdx++

				if idx2 >= 0x80 {
					idx = ((idx & 0x1F) << 7) | (idx2 & 0x7F)
					idx2 = int(src[srcIdx])
					srcIdx++
				}

				idx = (idx << 7) | (idx2 & 0x7F)

				if idx >= this.dictSize {
					break
				}
			}

			pe := &this.dictList[idx]

			// Sanity check
			if pe.pos < 0 || dstIdx+int(pe.length) >= dstEnd {
				err = fmt.Errorf("Invalid input data")
				break
			}

			// Add space if only delimiter between 2 words (not an escaped delimiter)
			if wordRun == true && pe.length > 1 {
				dst[dstIdx] = ' '
				dstIdx++
			}

			// Emit word
			if cur != TC_ESCAPE_TOKEN2 {
				dst[dstIdx] = pe.buf[pe.pos]
				dstIdx++
			} else {
				// Flip case of first character
				if isUpperCase(pe.buf[pe.pos]) {
					dst[dstIdx] = pe.buf[pe.pos] + 32
				} else {
					dst[dstIdx] = pe.buf[pe.pos] - 32
				}

				dstIdx++
			}

			buf := pe.buf[pe.pos+1 : pe.pos+int(pe.length)]

			for _, c := range buf {
				dst[dstIdx] = c
				dstIdx++
			}

			if pe.length > 1 {
				// Regular word entry
				wordRun = true
				delimAnchor = srcIdx
			} else {
				// Escape entry
				wordRun = false
				delimAnchor = srcIdx - 1
			}
		} else {
			wordRun = false
			delimAnchor = srcIdx - 1

			if (this.isCRLF == true) && (cur == LF) {
				dst[dstIdx] = CR
				dstIdx++
			}

			dst[dstIdx] = cur
			dstIdx++
		}
	}

	if (err == nil) && (srcIdx != srcEnd) {
		err = fmt.Errorf("Forward transform failed. Source index: %v, expected: %v", srcIdx, srcEnd)
	}

	return uint(srcIdx), uint(dstIdx), err
}

func (this TextCodec) MaxEncodedLen(srcLen int) int {
	// Space needed by destination buffer could be 3 x srcLength (if input data
	// is all delimiters). Limit to 1 x srcLength and let the caller deal with
	// a failure when the output is not smaller than the input
	return srcLen
}

// Create dictionary from array of words
func createDictionary(words []byte, dict []DictEntry, maxWords, startWord int) int {
	anchor := 0
	h := TC_HASH1
	nbWords := startWord

	for i := 0; (i < len(words)) && (nbWords < maxWords); i++ {
		cur := words[i]

		if isText(cur) {
			h = h*TC_HASH1 ^ int32(cur)*TC_HASH2
			continue
		}

		if isDelimiter(cur) && (nbWords < maxWords) && (i >= anchor+1) { // At least 2 letters
			dict[nbWords] = DictEntry{buf: words, pos: anchor, hash: h, idx: int32(nbWords), length: int16(i - anchor)}
			nbWords++
		}

		anchor = i + 1
		h = TC_HASH1
	}

	return nbWords
}

func isText(val byte) bool {
	return TC_TEXT_CHARS[val&0xFF]
}

func isLowerCase(val byte) bool {
	return (val >= 'a') && (val <= 'z')
}

func isUpperCase(val byte) bool {
	return (val >= 'A') && (val <= 'Z')
}

func isDelimiter(val byte) bool {
	return TC_DELIMITER_CHARS[val&0xFF]
}

// Unpack dictionary with 32 symbols (all lowercase except first word char)
func unpackDictionary32(dict []byte) []byte {
	buf := make([]byte, len(dict)*2)
	d := 0
	val := 0

	// Unpack 3 bytes into 4 6-bit symbols
	for i := range dict {
		val = (val << 8) | int(dict[i]&0xFF)

		if (i % 3) == 2 {
			for ii := 18; ii >= 0; ii -= 6 {
				c := (val >> uint(ii)) & 0x3F

				if c >= 32 {
					buf[d] = ' '
					d++
				}

				c &= 0x1F

				// Ignore padding symbols (> 26 and <= 31)
				if c <= 26 {
					buf[d] = byte(c + 'a')
					d++
				}
			}

			val = 0
		}
	}

	buf[d] = ' ' // End
	return buf[1 : d+1]
}
